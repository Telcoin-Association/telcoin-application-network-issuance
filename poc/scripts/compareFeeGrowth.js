#!/usr/bin/env node

/**
 * compareFeeGrowth.js
 *
 * This script contrasts fee growth calculations for a single Uniswap v4 LP
 * position using:
 *   1) The original tick range recorded in a TELx checkpoint JSON.
 *   2) The clamped tick range generated by TELx's getFeeGrowthInsideOffchain()
 *      helper (both bounds searched downward via findInitializedTickUnder()).
 *
 * It replicates the clamping logic from
 * telcoin-application-network-issuance/backend/calculators/TELxRewardsCalculator.ts,
 * calls StateView for fee growth at the provided start/end blocks, and prints
 * the resulting token0/token1 deltas alongside the computed fees using the
 * recorded liquidity. A large divergence between "original" and "clamped"
 * values indicates the clamping routine widened the fee window.
 *
 * Usage:
 *   node poc/scripts/compareFeeGrowth.js --checkpoint <file> \
 *        --tokenId <decimal> --poolId <0x...> --stateView <0x...> \
 *        --tickSpacing <int> --rpc <RPC_URL> [--startBlock <int>] [--endBlock <int>]
 *
 * Example:
 *   node poc/scripts/compareFeeGrowth.js \
 *     --checkpoint backend/checkpoints/polygon-ETH-TEL-7.json \
 *     --tokenId 44569 \
 *     --poolId 0x9a005a0c12cc2ef01b34e9a7f3fb91a0e6304d377b5479bd3f08f8c29cdf5deb \
 *     --stateView 0x5ea1bd7974c8a611cbab0bdcafcb1d9cc9b3ba5a \
 *     --tickSpacing 60 \
 *     --rpc https://polygon-rpc.example
 *
 * Requirements:
 *   npm install ethers@6
 */

const fs = require("fs");
const path = require("path");
const { ethers } = require("ethers");

const STATE_VIEW_ABI = [
  "function getFeeGrowthInside(bytes32 poolId, int24 tickLower, int24 tickUpper) view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)",
  "function getTickBitmap(bytes32 poolId, int16 wordPosition) view returns (uint256)",
  "function getTickInfo(bytes32 poolId, int24 tick) view returns (uint128 liquidityGross,int128 liquidityNet,uint256 feeGrowthOutside0X128,uint256 feeGrowthOutside1X128)"
];

const MAX_UINT256 = 2n ** 256n;
const Q128 = 2n ** 128n;

function die(message) {
  console.error(message);
  process.exit(1);
}

function parseArgs() {
  const args = process.argv.slice(2);
  const out = {};
  for (let i = 0; i < args.length; i++) {
    if (!args[i].startsWith("--")) {
      die(`Unexpected argument: ${args[i]}`);
    }
    const key = args[i].slice(2);
    const value = args[i + 1];
    if (value === undefined || value.startsWith("--")) {
      die(`Missing value for --${key}`);
    }
    out[key] = value;
    i += 1;
  }
  const required = ["checkpoint", "tokenId", "poolId", "stateView", "tickSpacing", "rpc"];
  for (const key of required) {
    if (!(key in out)) {
      die(`Missing required option --${key}`);
    }
  }
  out.tickSpacing = Number(out.tickSpacing);
  if (!Number.isInteger(out.tickSpacing) || out.tickSpacing <= 0) {
    die("--tickSpacing must be a positive integer");
  }
  out.tokenId = BigInt(out.tokenId);
  if ("startBlock" in out) out.startBlock = BigInt(out.startBlock);
  if ("endBlock" in out) out.endBlock = BigInt(out.endBlock);
  return out;
}

function parseCheckpoint(checkpointPath, tokenId) {
  const fullPath = path.resolve(checkpointPath);
  if (!fs.existsSync(fullPath)) {
    die(`Checkpoint file not found: ${fullPath}`);
  }
  const json = JSON.parse(fs.readFileSync(fullPath, "utf8"));
  const blockRange = json.blockRange || {};
  const startBlock = blockRange.startBlock ? parseBigIntString(blockRange.startBlock) : null;
  const endBlock = blockRange.endBlock ? parseBigIntString(blockRange.endBlock) : null;

  const entry = json.positions.find(([id]) => parseBigIntString(id) === tokenId);
  if (!entry) {
    die(`Token ID ${tokenId} not found in checkpoint positions`);
  }
  const [, state] = entry;
  const result = {
    startBlock,
    endBlock,
    tickLower: state.tickLower,
    tickUpper: state.tickUpper,
    liquidity: parseBigIntString(state.liquidity),
  };
  return result;
}

function parseBigIntString(str) {
  if (typeof str === "bigint") return str;
  if (typeof str === "number") return BigInt(str);
  if (typeof str === "string") {
    const normalized = str.endsWith("n") ? str.slice(0, -1) : str;
    return BigInt(normalized);
  }
  die(`Unable to parse bigint from value: ${str}`);
}

function compressTick(tick, spacing) {
  let q = Math.trunc(tick / spacing);
  const r = tick % spacing;
  if (r !== 0 && r < 0) q -= 1;
  return q;
}

function tickToWord(compressedTick) {
  return Math.trunc(compressedTick / 256);
}

async function findInitializedTickUnder(contract, poolId, startTick, spacing, blockTag, searchLimit = 2560) {
  let compressed = compressTick(startTick, spacing);
  const startWord = tickToWord(compressed);
  let word = startWord;
  for (let wordOffset = 0; wordOffset < searchLimit; wordOffset++, word--) {
    const bitmap = await contract.getTickBitmap(poolId, word, { blockTag });
    if (bitmap === 0n) continue;
    const startBit = wordOffset === 0 ? (compressed & 255) : 255;
    for (let bit = startBit; bit >= 0; bit--) {
      if ((bitmap & (1n << BigInt(bit))) !== 0n) {
        const compressedResult = BigInt(word) * 256n + BigInt(bit);
        const tick = Number(compressedResult) * spacing;
        return tick;
      }
    }
  }
  return null;
}

async function getFeeGrowthInside(contract, poolId, tickLower, tickUpper, blockTag) {
  const [g0, g1] = await contract.getFeeGrowthInside(poolId, tickLower, tickUpper, { blockTag });
  return [BigInt(g0), BigInt(g1)];
}

function feeDelta(start, end) {
  return (end - start + MAX_UINT256) % MAX_UINT256;
}

function computeFees(liquidity, delta0, delta1) {
  return {
    token0: (liquidity * delta0) / Q128,
    token1: (liquidity * delta1) / Q128,
  };
}

function formatTokenAmount(amount) {
  return Number(amount) === 0 ? "0" : amount.toString();
}

async function main() {
  const args = parseArgs();
  const checkpoint = parseCheckpoint(args.checkpoint, args.tokenId);

  const startBlock = args.startBlock ?? checkpoint.startBlock;
  const endBlock = args.endBlock ?? checkpoint.endBlock;
  if (!startBlock || !endBlock) {
    die("Start/end block not available in checkpoint; please provide --startBlock and --endBlock");
  }

  const provider = new ethers.JsonRpcProvider(args.rpc);
  const contract = new ethers.Contract(args.stateView, STATE_VIEW_ABI, provider);
  const poolIdBytes = args.poolId;

  const originalTicks = {
    lower: checkpoint.tickLower,
    upper: checkpoint.tickUpper,
  };

  const clamped = {
    lower: await findInitializedTickUnder(contract, poolIdBytes, originalTicks.lower, args.tickSpacing, startBlock),
    upper: await findInitializedTickUnder(contract, poolIdBytes, originalTicks.upper, args.tickSpacing, startBlock),
  };

  if (clamped.lower === null || clamped.upper === null) {
    die("Unable to find initialized ticks while clamping; consider increasing search limit");
  }

  const [startOrig0, startOrig1] = await getFeeGrowthInside(contract, poolIdBytes, originalTicks.lower, originalTicks.upper, startBlock);
  const [endOrig0, endOrig1] = await getFeeGrowthInside(contract, poolIdBytes, originalTicks.lower, originalTicks.upper, endBlock);

  const [startClamp0, startClamp1] = await getFeeGrowthInside(contract, poolIdBytes, clamped.lower, clamped.upper, startBlock);
  const [endClamp0, endClamp1] = await getFeeGrowthInside(contract, poolIdBytes, clamped.lower, clamped.upper, endBlock);

  const deltaOrig0 = feeDelta(startOrig0, endOrig0);
  const deltaOrig1 = feeDelta(startOrig1, endOrig1);
  const deltaClamp0 = feeDelta(startClamp0, endClamp0);
  const deltaClamp1 = feeDelta(startClamp1, endClamp1);

  const feesOrig = computeFees(checkpoint.liquidity, deltaOrig0, deltaOrig1);
  const feesClamp = computeFees(checkpoint.liquidity, deltaClamp0, deltaClamp1);

  console.log("=== Input Summary ===");
  console.log(`Checkpoint: ${path.resolve(args.checkpoint)}`);
  console.log(`Token ID : ${args.tokenId}`);
  console.log(`Pool ID  : ${args.poolId}`);
  console.log(`StateView: ${args.stateView}`);
  console.log(`Tick spacing: ${args.tickSpacing}`);
  console.log(`Liquidity: ${checkpoint.liquidity.toString()}`);
  console.log(`Original ticks: [${originalTicks.lower}, ${originalTicks.upper}]`);
  console.log(`Clamped  ticks: [${clamped.lower}, ${clamped.upper}]`);
  console.log(`Start block: ${startBlock.toString()}  End block: ${endBlock.toString()}`);
  console.log("");

  console.log("=== Fee Growth ===");
  console.log("Original start:", startOrig0.toString(), startOrig1.toString());
  console.log("Original end  :", endOrig0.toString(), endOrig1.toString());
  console.log("Clamped  start:", startClamp0.toString(), startClamp1.toString());
  console.log("Clamped  end  :", endClamp0.toString(), endClamp1.toString());
  console.log("");

  console.log("=== Fee Deltas ===");
  console.log("Original Δ0:", deltaOrig0.toString());
  console.log("Original Δ1:", deltaOrig1.toString());
  console.log("Clamped  Δ0:", deltaClamp0.toString());
  console.log("Clamped  Δ1:", deltaClamp1.toString());
  console.log("");

  console.log("=== Implied Fees (liquidity * Δ / Q128) ===");
  console.log("Original token0:", formatTokenAmount(feesOrig.token0));
  console.log("Original token1:", formatTokenAmount(feesOrig.token1));
  console.log("Clamped  token0:", formatTokenAmount(feesClamp.token0));
  console.log("Clamped  token1:", formatTokenAmount(feesClamp.token1));
  console.log("");

  console.log("Done.");
}

main().catch((err) => {
  console.error("Error:", err);
  process.exit(1);
});
